## 模板字符串

```
`hello ${xxx } `
```

`${}`里面可以放变量、算术计算、三目运算、对象属性、创建对象、调用函数、访问数组元素，有返回值的合法的js表达式。

不能放：没有返回值的js表达式；判断、循环等程序结构。



## var的问题

会被声明提前，打乱程序正常的执行顺序。没有块级作用域；代码块内的变量会超出代码块范围，影响外部的变量。

什么是块级作用域：(js中没有，其它语言才有)
 • 指除了对象{}和function的{}之外，
 • 其余if else、for等分支和循环结构的{}范围
 • 在其他语言中称为块级作用域。
 • 其他语言中，程序块{}内的变量，出了所在的程序块{}，就不能使用

let 不会声明提前，有块级作用域。其本质是匿名函数自调。在相同的作用域内禁止声明同名变量。不在window的属性中。



## 普通for循环：

• 1). 优点: 既可遍历索引数组，又可以遍历类数组对象(arguments)——只要下标是 数字

• 2). 缺点: 没有可简化的空间



forEach：

• 1). 优点: 可以配合ES6的箭头函数，很简化
 • 2). 缺点: 只能遍历数字下标的索引数组，无法遍历类数组对象

for of: 

• a. 无法获得下标位置i，只能获得元素值
• b. 无法控制遍历的顺序或步调，只能从头到尾，一个挨一个的顺序遍历

• c. 无法遍历下标名为自定义下标的对象和关联数组

但是

• 因为绝大多数数组都是数字下标，
 • 绝大多数循环都是从头到尾，一个挨一个遍历的，

 • 且绝大多数循环不太关心下标位置，
 • 只关心元素值，
 • 所以for of将来用的还是非常多的!

![compareEachfor](/Users/liquan/Personal/开发随笔/compareEachfor.png)

总结

• 下标为数字，首选for of
 • 下标为自定义字符串，首选for in

## 参数增强



1）参数默认值：

function 函数名(形参1=默认值1,形参2=默认值2, ...){

//调用函数时，给形参传了实参值， // 则首选用户传入的实参值。 //如果没有给形参传是实参值，
 // 则形参默认启用=右边的默认值。

}

2）剩余参数(rest)

• 用arguments实现



箭头函数不支持arguments

如果箭头函数遇到参数个数不确定时，怎么办?

今后，只要在ES6箭头函数中碰到参数个数不确定的情况，都要用剩余参数语法 来代替arguments

​						收集

​						\↓/
 var 函数名=( ...数组名arr )=>{

//将来传入函数的所有实参值，都会被...收集起来，保存到...后指定的数 组中。

}

• 1). 支持箭头函数
 • 2). 生成的数组是纯正的数组类型，所以使用数组家所有函数 

• 3). 自定义数组名arr，比arguments简单的多!

为什么叫rest剩余参数?

• ...可以和其它形参配合使用，
 • 只获得其它形参不要的剩余参数。

var 函数名=(形参1, 形参2,...数组名arr)=>{ //形参1接收实参1
 //形参2接收实参2 //...数组名arr接收除实参值1、2之外其余实参

}

• 今后，只要箭头函数中，不确定实参值个数时，
 • 都可用”...数组名”代替arguments接住所有或剩余实参值。



不能使用箭头函数的地方/箭头函数缺点

• 构造函数不能用
 • 对象的方法不能用
 • 原型对象方法不能用
 • DOM中事件处理函数不能用
 • 箭头函数无法用call,apply,bind改变this • 箭头函数不支持arguments
 • 箭头函数没有prototype

• 1). 定义函数时，形参列表中的...，表示收集
 • 2). 调用函数时，实参列表中的...，反而表示拆散

## 语法糖: (时髦的简写)

1). 复制一个数组

```javascript
var arr1=[1,2,3]; 
//复制arr1中所有元素保存到新数组arr2中
var arr2=[...arr1];
```

2).拼接多个数组和多个元素

2). 合并多个数组和元素:

````javascript
var arr1=[1,2,3];
var arr2=[5,6,7]; 
//拼接多个数组和多个元素为一个新的数组 
var arr3=[...arr1,4,...arr2,8];
````

3). 克隆一个对象

```javascript
var lilei={ sname:"Li Lei", sage:11 }; //克隆lilei
var lilei2={...lilei};
```

4). 合并多个对象和属性:

````javascript
var obj1={ x:1, y:2 };
var obj2={ i:4, j:5 };
var obj3={...obj1, z:3, ...obj2, k:6};
var obj3={x:1, y:2,z:3,i:4, j:5, k:6}//new Object()
````



## 解构(destruct)

• 旧js中，要想使用对象中的成员，或数组中的元素，都必须带着`对象名.`或`数组名[]`前缀。

实际开发中，对象或数组的嵌套结构可能很深。前缀就可能写很长:`对象名.属性名.更子一级属性名....`, 非常麻烦。比如:

```javascript
var lilei={
sname:”Li Lei”, address:{
street: “万寿路西街”, //lilei.address.street city:”北京” //lilei.address.city
} }
```

解决：今后，遇到一个复杂的对象或数组时，都可以通过解构方式，来减少数组或对象的嵌套结构便于使用。

### 数组解构

```javascript
var arr=[2021,6,7,9,33]; // 01234
//如果不想要年，只想要月和日
var [ ,m,d]=arr;//正确, 数组中允许空“,”
console.log(`本月是${m}月`); //6 
console.log(`今天是${d}号`); //7
```

### 对象解构

```javascript
var lilei={ sname:"Li Lei", sage:11}
var {sname, sage , className}=lilei;//解构失败，没有ClassName，返回undefined
console.log(`姓名:${sname}`) //Li Lei 
console.log(`年龄:${sage}`) //11
console.log(`班级:${className}`) //undefined
```

ES6简写:

• 问题：要解构的属性在原对象中的原属性名起的很好了，解构时，我也想用原属性名作为变量名，单独用。不想改名! 但是，却要:左右两边重复写两遍相同的属性名。

解决：每当对象中:左边的属性名和:右边的变量名刚好相同时，其实只写一个名字即可。一个名字两用，既当属性名配对，又当变量名接值



解构失败: 数组解构或者对象解构中，试图获取原数组或对象中不存在的位置或属性值，就会解构失败，解构失败不报错！而是返回undefined给=左边对应的变量。

### 参数解构

单靠参数默认值，无法解决任意一个形参不确定有没有的情况。

解决： 今后只要发现任意一个实参值都可能没有，但是又要求实参值必须传给指定的形参， 顺序不能乱，都可用参数解构:

```
i.定义函数时: 
function 函数名({
//配对儿 :接实参值
 属性名1: 形参1,
 属性名2: 形参2,
		... : ... 
	}){
	函数体
}
 ii. 调用函数时:
 函数名({
//配对儿 
属性名1: 实参值1, 
属性名2: 实参值2, ... : ...
})
```

属性名与形参变量名通常不会起两个名字，绝大多数情况下同名。 

 解决: ES6简写

```
定义函数时:
function 函数名({//一个名字两用,既配对，又接值
	属性名1,属性名2, xxx 
}){
	函数体
}
ii. 调用时保持不变 
函数名({//配对儿
属性名1: 实参值1, 属性名2: 实参值2,... })
```

问题: 担心形参可能接不到实参值

解决: ES6简写+参数默认值 

```
i.定义函数时:
 function 函数名({
//一个名字两用,既配对，又接值
属性名1=默认值1,属性名2=默认值2, xxx=xxx 
}){
函数体
}
ii. 调用时保持不变 
函数名({
//配对儿
属性名1: 实参值1, 属性名2: 实参值2, ... : ... })
```

本质：因为定义函数时，形参是对象结构，调用函数时，实参值也是对象结构，所以，参数结构的本质，其实还是对象结构——属性对属性

```
function order({ zhushi='香辣鸡腿堡',xiaochi='薯条',yinliao='可乐'}) {
	console.log(`你点的套餐是：主食：香辣鸡腿堡 小吃：薯条 饮料：可乐 `)
}
order(xiaochi:'红豆派')//你点的套餐是：主食：香辣鸡腿堡 小吃：红豆派 饮料：可乐

```

 ## promise

```
function 前一项任务(){ 
	return new Promise(
		// 赠 两个开关 
		function(成功的开关open, 失败的开关err){
      var 变量=值 
      原异步任务 
      异步任务最后一句话 
      如果异步任务执行成功
      调用成功的开关open( 变量 ) 
      //->通向.then()，正常自动执行.then中的下一项任务
      否则如果异步任务执行失败 调用失败的开关err(错误提示信息)
      //->通向最后的.catch( )，不同.then()，后续.then()不再执行。 
    }
	)
}
```

Promise的三大状态：

 1). pending(挂起)。当异步任务执行过程中， 整个new Promise()对象处于pending(挂起)状态。

• 2). fulfilled(成功)。当异步任务成功执行完，调用成功的开关函数(resolve())时，整个new Promise()对象切换为fulfilled(成功)状态，new Promise()会自动调用.then()执行下一项任务。

3). rejected(出错)。当异步任务执行出错，调用失败的开关(reject())函数时，整个new Promise()对象切换为rejected(出错)状态， new Promise()会自动调用.catch()执行错误处理代码。

Async 和 await

其实就是promise中.then()的简写 目的是彻底消除嵌套。



1. 只有基于Promise的函数，才支持async和await
2. await必须用在被async标记的函数内

3. 外层函数必须用async标记。目的是告诉主程序，这段函数内的 代码整体是异步执行的。不影响主程序的执行。
4. await必须写在前一项任务之前
5. await的作用等效于.then()，用来通知程序必须等待前一项任务执 行完，才能继续执行后续任务。
6. 一旦使用了await，前一项任务的resolve(返回值)，可以像普通函 数一样用=接住。后续代码可继续使用该变量里获得的返回值。
7. await和.then()一样，可多次使用。控制多个异步任务顺序执行。

```
ran().then(tao).then(dong)
可改为:
(async ()=>{
var bang=await ran();
bang=await tao(bang);
dong(bang); })()
```



所以，async和await的组合 虽然相对于主程序，整体是异步的 但async内部的多个await 是同步顺序执行的。

用try catch组合代替了.catch(function(){ ... })函数嵌套调用，可自动接住 promise函数中reject()抛出的异常信息。

```
(async ()=>{ 
	try{
    var bang=await ran();
    bang=await tao(bang);
    dong(bang); 
   }catch(err){ 
    //错误处理代码
   } 
  }
)()
```

























